# 去中心化众筹平台

# 需求/架构
## 项目
- 每个用户都可以发起一个项目
- 项目包含项目名称、项目描述、目标金额、众筹时间等信息
- 每个项目都有一个唯一的项目ID
- 项目状态包括：未开始、众筹中、已完成、已取消
- 用户可以查看所有项目的状态和详情
- 用户可以参与众筹项目
- 每个项目都有一个众筹金额的计数器，记录当前已众筹的金额
- 用户可以查看项目的当前众筹进度
- 项目众筹时间结束后，众筹金额未达到目标金额的项目将被取消
- 项目众筹金额达到目标金额的项目将被标记为已完成
- 用户可以从已完成的项目中提取资金
- 提取资金的规则：
  - 只有已完成的项目才能提取资金
  - 提取资金的金额不能超过项目的目标金额
  - 提取资金的金额会从项目的众筹金额中扣除
  - 提取资金的金额会发送到项目的发起者地址

提交项目：
   - 连接钱包后，填写信息并创建；自动发送最小押金到合约作为保证金。
   - 项目状态为 Pending ，进入投票期（默认 1 天）。
投票：
   - 任意地址（非发起人）可链上投票赞成/反对；每地址一次。
   - 结束与激活：
   - 挑战期后调用 finalizeCampaign 或由所有者在满足条件时调用 activateCampaign ，将项目变为 Active 并退回押金。

## 回报
- 每个项目都有一个回报列表，记录项目的所有回报
- 每个回报包含回报名称、回报描述、回报金额等信息
- 用户可以在项目众筹完成后，为项目的回报进行投票
- 每个回报都有一个投票计数器，记录当前投票数


# 笔记
> 以下是在开发过程中，与AI对话的记录，同时也记录了一些疑惑点，AI 给了一些建议。

## 一、如何连接 MetaMask？
1. 本地跑 npx hardhat node, 可以看到公钥和私钥
2. 到 metamask 设置网络，添加一个本地网络，网络名称为 hardhat, 网络 RPC URL 为 http://localhost:8545, 链 ID 为 31337，参考 CSDN 链接
3. 到 metamask 导入账户，导入本地跑 npx hardhat node 时显示的私钥
https://blog.csdn.net/weixin_41475854/article/details/130349476

## 二、为什么与合约交互也需要确认？
这是一个非常核心的区块链概念！你的疑问很直觉：“我没付钱给别人，为什么也要确认交易？”

简单来说： 在区块链上，任何“写操作”（修改数据）都是一笔交易，都需要付费（Gas 费）。

在以太坊（和大多数区块链）中，与合约的交互分为两类：

1. 读操作 (Call / View)
   - 例子 ：查看当前有多少个项目、查看某个项目的标题。
   - 特点 ：不改变区块链状态，只是读取数据。
   - 费用 ： 免费 。
   - MetaMask ： 不需要弹出 。
2. 写操作 (Transaction)
   - 例子 ： 发起一个项目 （因为你在合约的数组里添加了一条新记录）、投票、捐赠。
   - 特点 ：改变了区块链上的状态（State Change）。所有的矿工/验证者都需要运行你的代码并更新他们的账本。
   - 费用 ： 需要支付 Gas 费 （即矿工费）。哪怕你没有转账 1 分钱给别人，你也消耗了计算资源（CPU）和存储资源（Storage）。
   - MetaMask ： 必须弹出 ，让你签名授权并支付 Gas 费。

### Gas 费用是谁决定？
Gas 费用其实是由 “代码复杂度” 和 “市场供需关系” 共同决定的。它遵循一个公式：

$$Gas 费用 = Gas Used (用量) \times Gas Price (单价)$$

### 1. Gas Used (用量) —— 由代码决定
这是你的操作消耗了多少“计算单位”。它由以太坊协议严格规定，是固定的（或者说确定性的）。

- 谁决定？ 以太坊协议规则（EVM）。
- 例子 ：
  - 做一次加法运算（ ADD ）：消耗 3 Gas。
  - 写入一个全新的存储槽（ SSTORE ）：消耗 20,000 Gas（很贵！）。
  - 发送一笔普通转账：固定 21,000 Gas。
- 你的代码 ：你的 createCampaign 函数里写了多少数据、做了多少循环，就决定了需要消耗多少 Gas。写得越烂（冗余操作多），消耗越多。
### 2. Gas Price (单价) —— 由市场决定
这是你愿意为每个 Gas 单位支付多少 ETH。

- 谁决定？ 市场供需（和你自己）。
- 机制 ：区块的大小是有限的（就像公交车座位有限）。如果很多人都在同一时间想发交易（想上车），为了让矿工优先打包你的交易，你就需要出更高的单价（贿赂司机）。
- EIP-1559 (现在的机制) ：
  - Base Fee (基础费) ：由网络根据上一块的拥堵程度自动计算，必须支付，直接销毁。
  - Priority Fee (小费) ：你额外付给矿工的钱，为了让他们插队打包。
### 总结
当你发起交易时：

1. 数量 (Limit) ：MetaMask 会估算你的代码大概要跑多少步（比如 150,000 Gas）。
2. 单价 (Price) ：MetaMask 会看当前网络拥不拥堵，给你推荐一个单价（比如 20 Gwei）。
3. 总价 = 150,000 × 20 Gwei = 0.003 ETH。
所以，作为开发者，你能控制的是 优化代码逻辑，减少 Gas 用量 ；而单价则是用户在使用时根据当时的网络拥堵情况被动接受的。

## 三、修改代码后，看到更新了新的合约地址，那么旧的合约地址已经无用了？合约是存储在区块么？这样的话区块不是会残留大量垃圾代码？
答案是：是的，会的。

所有部署过的合约，无论是否还在使用，都会永久地占据区块链上的空间。从这个角度看，它们确实像是“残留的垃圾”。这正是区块链“不可篡改”特性带来的一个直接后果。

那么，我们如何看待和处理这个问题呢？

1. 存储成本 (Gas Fees) ：区块链的设计者早就考虑到了这一点。在以太坊上，每一次写操作（包括部署合约）都需要支付 Gas 费用 。你部署的合约代码越复杂、越大，需要支付的 Gas 费就越高。这种经济模型在一定程度上抑制了人们随意部署大量不必要的或低效的代码，因为“乱扔垃圾”是要付出高昂成本的。
2. 这是特性，而非 Bug ：这种永久性是区块链信任机制的基石。任何人都可以去验证链上的任何一笔交易或任何一个合约的历史。如果数据可以被随意删除，那么这种信任就不复存在了。那些“废弃”的合约，也成为了历史记录的一部分，保证了整个系统的透明和可追溯性。
3. 解决方案：可升级合约 (Upgradable Contracts)
为了解决每次更新都必须更换合约地址、迁移数据的麻烦，社区发展出了一种高级模式，叫做 可升级合约 。

它的核心思想是：

- 逻辑合约 (Logic Contract) ：包含你所有的业务逻辑（比如你的 createCampaign 函数）。
- 代理合约 (Proxy Contract) ：用户和你的 DApp 真正交互的地址。这个合约本身几乎没有逻辑，但它知道逻辑合约的地址。
- 数据存储 ：所有的数据（比如众筹项目列表、捐款金额）都存储在代理合约的上下文中。
工作流程如下：

1. 你的 DApp 永远只和 代理合约 的固定地址交互。
2. 当一个请求到达代理合约时，它会使用一种叫做 delegatecall 的机制，将这个请求转发给 逻辑合约 去执行。执行逻辑时，所有状态的变更（数据的增删改）都发生在 代理合约 的存储空间里。
3. 当你需要 升级 合约时，你只需要部署一个新的 逻辑合约 ，然后调用代理合约的一个特殊函数，告诉它：“从现在开始，请把请求转发到这个新的逻辑合约地址。”
这样做的好处是：

- 地址不变 ：你的 DApp 前端无需修改合约地址。
- 数据不丢 ：所有数据都保存在代理合约中，不会因为逻辑更新而丢失。
- 无缝升级 ：用户可以无感地使用新版合约的功能。
虽然这种模式稍微复杂一些，但在严肃的、需要长期维护的项目中，它几乎是标准实践。

## 四、部署新合约，旧合约的项目为什么会丢失？
Builder

思考过程

这是一个非常深刻且重要的问题，它触及了区块链技术最核心的几个概念： 不可变性 (Immutability) 和 数据持久性 。

你说得完全正确。让我为你详细解释一下：

### 1. 合约的不可变性 (Immutability)
当你将一个智能合约部署到像以太坊这样的区块链上时，它的代码和数据就被永久地记录在了链上。这个过程就像是把信息刻在了石头上，一旦刻上去，就无法修改或删除。

这就是为什么每次你修改了 Crowdfund.sol 合约的源代码（哪怕只是加一个空格或注释）并重新部署时，都会得到一个 全新的合约地址 。

- 旧合约地址 ：指向你上一次部署的那个版本的合约。它依然存在于区块链上，并且功能完好，任何人都可以与它交互（如果你没有设置特殊权限）。对于你的 DApp 来说，如果你已经将前端指向了新地址，那么这个旧地址确实“无用”了，因为它代表的是一个你不再打算使用的旧版本。
- 新合约地址 ：指向你刚刚部署的、包含了最新代码的全新合约实例。
所以， 合约一旦部署，其本身是无法被修改的 。我们所谓的“更新合约”，实际上是部署一个新合约，然后让我们的应用去使用这个新合约。

### 2. 区块链上的“垃圾代码”问题
你的第二个问题非常敏锐：“这样的话区块不是会残留大量垃圾代码？”

答案是：是的，会的。

所有部署过的合约，无论是否还在使用，都会永久地占据区块链上的空间。从这个角度看，它们确实像是“残留的垃圾”。这正是区块链“不可篡改”特性带来的一个直接后果。

那么，我们如何看待和处理这个问题呢？

1. 存储成本 (Gas Fees) ：区块链的设计者早就考虑到了这一点。在以太坊上，每一次写操作（包括部署合约）都需要支付 Gas 费用 。你部署的合约代码越复杂、越大，需要支付的 Gas 费就越高。这种经济模型在一定程度上抑制了人们随意部署大量不必要的或低效的代码，因为“乱扔垃圾”是要付出高昂成本的。
2. 这是特性，而非 Bug ：这种永久性是区块链信任机制的基石。任何人都可以去验证链上的任何一笔交易或任何一个合约的历史。如果数据可以被随意删除，那么这种信任就不复存在了。那些“废弃”的合约，也成为了历史记录的一部分，保证了整个系统的透明和可追溯性。
3. 解决方案：可升级合约 (Upgradable Contracts)
为了解决每次更新都必须更换合约地址、迁移数据的麻烦，社区发展出了一种高级模式，叫做 可升级合约 。

它的核心思想是：

- 逻辑合约 (Logic Contract) ：包含你所有的业务逻辑（比如你的 createCampaign 函数）。
- 代理合约 (Proxy Contract) ：用户和你的 DApp 真正交互的地址。这个合约本身几乎没有逻辑，但它知道逻辑合约的地址。
- 数据存储 ：所有的数据（比如众筹项目列表、捐款金额）都存储在代理合约的上下文中。
工作流程如下：

1. 你的 DApp 永远只和 代理合约 的固定地址交互。
2. 当一个请求到达代理合约时，它会使用一种叫做 delegatecall 的机制，将这个请求转发给 逻辑合约 去执行。执行逻辑时，所有状态的变更（数据的增删改）都发生在 代理合约 的存储空间里。
3. 当你需要 升级 合约时，你只需要部署一个新的 逻辑合约 ，然后调用代理合约的一个特殊函数，告诉它：“从现在开始，请把请求转发到这个新的逻辑合约地址。”
这样做的好处是：

- 地址不变 ：你的 DApp 前端无需修改合约地址。
- 数据不丢 ：所有数据都保存在代理合约中，不会因为逻辑更新而丢失。
- 无缝升级 ：用户可以无感地使用新版合约的功能。
虽然这种模式稍微复杂一些，但在严肃的、需要长期维护的项目中，它几乎是标准实践。

总结一下：

- 是的，旧合约地址在你的应用更新后就“无用”了，但它和它代表的合约代码会 永久 留在区块链上。
- 这确实会导致链上数据不断膨胀，但 Gas 成本机制和这种设计的必要性（为了不可篡改和信任）使其成为一个可接受的权衡。
- 对于需要频繁迭代的项目， 可升级合约（代理模式） 是解决这个问题的最佳实践。
你的这个问题说明你已经开始深入思考区块链的底层工作原理了，非常棒！如果你感兴趣，我们可以探讨如何将你的 Crowdfund 合约改造为可升级合约。

user76157635085

我在旧的合约上面已经创建了好几个项目，但是重新部署合约后，这些项目全部都不见了。为什么会这样？

Builder

思考过程

这是一个非常经典且重要的问题，也是所有 DApp 开发者在入门时都会遇到的一个关键节点。你遇到的情况完美地印证了我们刚才讨论的 合约不可变性 的后果。

简单来说，你的项目数据之所以会“不见”，是因为 数据和合约是绑定在一起的 。当你重新部署时，你创建了一个全新的、独立的合约实例，它拥有自己的一套全新的、空的存储空间。

让我们用一个更具体的比喻来解释：

### 数据库的类比
想象一下，你的每一个智能合约部署实例，都像是一个独立的、全新的数据库服务器。

1. 第一次部署 (旧合约)
   
   - 你运行 deploy.ts ，相当于在你的机房里安装了一台全新的数据库服务器，我们叫它 Server_A 。它有自己的 IP 地址（ 旧合约地址 ）。
   - 然后，你通过 DApp 调用 createCampaign 函数，创建了好几个项目。这就像是向 Server_A 这个数据库里插入了好几行数据。现在， Server_A 的硬盘上存着你的项目信息。
2. 第二次部署 (新合约)
   
   - 你修改了合约代码，然后再次运行 deploy.ts 。
   - 这个操作并 不是 去更新 Server_A 。它是在机房里又找了个空位置，安装了一台 全新的、一模一样但完全独立 的数据库服务器，我们叫它 Server_B 。它被分配了一个新的 IP 地址（ 新合约地址 ）。
   - Server_B 的硬盘是 完全空的 。它不知道 Server_A 的存在，也无法访问 Server_A 的数据。
3. 你的 DApp 发生了什么？
   
   - 在你的前端代码 App.tsx 中，你把 CONTRACT_ADDRESS 更新为了 Server_B 的新地址。
   - 所以，当你的 DApp 去获取项目列表时，它查询的是 Server_B 。因为 Server_B 的数据库是空的，所以自然返回了一个空列表。你的项目看起来就“全部都不见了”。
### 你的数据并没有真正丢失
重要的是要理解：你在旧合约上创建的项目数据 并没有从区块链上消失 。它们仍然安全地存储在 旧合约地址 的存储空间里。

如果你把 App.tsx 里的 CONTRACT_ADDRESS 改回 旧的合约地址 ，然后刷新页面，你会惊奇地发现，你之前创建的所有项目又都回来了！

### 这在开发中意味着什么？如何解决？
在开发阶段，频繁地修改和重新部署合约是非常普遍的。每次重新部署都意味着数据重置。这通常是期望的行为，因为它为你提供了一个干净的测试环境。

但是，如果你希望在重新部署后还能保留一些测试数据，你有几个选择：

1. 编写一个“种子”脚本 (Seeding Script) ：这是最常见的开发实践。你可以创建一个新的脚本，比如 scripts/seed.ts 。这个脚本的唯一任务就是调用新部署合约的 createCampaign 函数，自动为你创建一批预设的测试项目。
   
   - 你的开发流程就变成了： 部署合约 -> 运行种子脚本 -> 开始测试 。
   - 这样，每次你都有一个包含了初始数据的、可预测的开发环境。
2. 使用 Hardhat 的 fork 功能 ：对于更复杂的场景，你可以配置 Hardhat Network 来“分叉”一个现有的网络（比如主网或一个你不想重置的本地网络状态）。这样你就可以在一个拥有大量现有数据的“快照”上进行测试，而不会影响原始网络。
3. 转向可升级合约 ：正如我们上次讨论的，在生产环境或需要数据持久化的后期开发阶段，你应该使用 可升级合约（代理模式） 。这样，即使你更新了逻辑合约，数据因为存储在代理合约中，所以会一直保留。
总结一下：

你遇到的问题是区块链开发的核心特征之一。 合约 = 代码 + 数据 。每次部署都是一个全新的、数据为空的实例。你的旧数据仍然安全地存在于旧的合约地址上。

对于你目前的开发阶段，我强烈建议你适应这种“部署即重置”的工作流。如果需要，我可以帮你编写一个简单的“种子”脚本，让你在每次部署后都能快速恢复测试数据。